From 168f52af835b1a777bf69a374b6848436e64c400 Mon Sep 17 00:00:00 2001
From: Xiaohanjlll <hanx.xiao@intel.com>
Date: Tue, 23 May 2023 08:59:09 +0800
Subject: [PATCH] fix csr

Signed-off-by: Xiaohanjlll <hanx.xiao@intel.com>
---
 .../spdm_requester_lib/libspdm_req_get_csr.c  |  12 +-
 library/spdm_responder_lib/libspdm_rsp_csr.c  |   5 +-
 unit_test/test_spdm_requester/get_csr.c       | 111 ++++++++++++-
 unit_test/test_spdm_responder/csr.c           | 148 ++++++++++++++++++
 4 files changed, 265 insertions(+), 11 deletions(-)

diff --git a/library/spdm_requester_lib/libspdm_req_get_csr.c b/library/spdm_requester_lib/libspdm_req_get_csr.c
index 159c53c8..ba4fde5a 100644
--- a/library/spdm_requester_lib/libspdm_req_get_csr.c
+++ b/library/spdm_requester_lib/libspdm_req_get_csr.c
@@ -93,16 +93,16 @@ static libspdm_return_t libspdm_try_get_csr(libspdm_context_t *spdm_context,
     spdm_request->opaque_data_length = opaque_data_length;
     spdm_request->requester_info_length = requester_info_length;
 
-    if (opaque_data_length != 0) {
+    if (requester_info_length != 0) {
         libspdm_copy_mem(spdm_request + 1,
                          spdm_request_size - sizeof(spdm_get_csr_request_t),
-                         (uint8_t *)opaque_data, opaque_data_length);
+                         (uint8_t *)requester_info, requester_info_length);
     }
 
-    if (requester_info_length != 0) {
-        libspdm_copy_mem((uint8_t *)(spdm_request + 1) + opaque_data_length,
-                         spdm_request_size - sizeof(spdm_get_csr_request_t),
-                         (uint8_t *)requester_info, requester_info_length);
+    if (opaque_data_length != 0) {
+        libspdm_copy_mem((uint8_t *)(spdm_request + 1) + requester_info_length,
+                         spdm_request_size - sizeof(spdm_get_csr_request_t) - requester_info_length,
+                         (uint8_t *)opaque_data, opaque_data_length);
     }
 
     LIBSPDM_ASSERT(spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_12);
diff --git a/library/spdm_responder_lib/libspdm_rsp_csr.c b/library/spdm_responder_lib/libspdm_rsp_csr.c
index 51a2b19e..c5674b70 100644
--- a/library/spdm_responder_lib/libspdm_rsp_csr.c
+++ b/library/spdm_responder_lib/libspdm_rsp_csr.c
@@ -24,7 +24,6 @@ libspdm_return_t libspdm_get_response_csr(libspdm_context_t *spdm_context,
     uint8_t *csr_p = csr_pointer;
     uint16_t requester_info_length;
     uint16_t opaque_data_length;
-    uint8_t *opaque_data;
     uint8_t *requester_info;
     bool need_reset;
 
@@ -113,9 +112,7 @@ libspdm_return_t libspdm_get_response_csr(libspdm_context_t *spdm_context,
                                                response_size, response);
     }
 
-    opaque_data = (void*)((size_t)(spdm_request + 1));
-
-    requester_info = (void*)(opaque_data + opaque_data_length);
+    requester_info = (void*)((size_t)(spdm_request + 1));
 
     need_reset = libspdm_is_capabilities_flag_supported(
         spdm_context, false, 0,
diff --git a/unit_test/test_spdm_requester/get_csr.c b/unit_test/test_spdm_requester/get_csr.c
index 7bb766e4..e142d085 100644
--- a/unit_test/test_spdm_requester/get_csr.c
+++ b/unit_test/test_spdm_requester/get_csr.c
@@ -10,6 +10,27 @@
 
 #if LIBSPDM_ENABLE_CAPABILITY_GET_CSR_CAP
 
+uint8_t m_csr_opaque_data[8] = "libspdm";
+uint16_t m_csr_opaque_data_size = sizeof(m_csr_opaque_data);
+
+/*ECC 256 req_info(include right req_info attribute)*/
+static uint8_t right_req_info[] = {
+    0x30, 0x81, 0xBF, 0x02, 0x01, 0x00, 0x30, 0x45, 0x31, 0x0B, 0x30, 0x09,
+    0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55,
+    0x04, 0x08, 0x0C, 0x0A, 0x53, 0x6F, 0x6D, 0x65, 0x2D, 0x53, 0x74, 0x61, 0x74, 0x65, 0x31, 0x21,
+    0x30, 0x1F, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x0C, 0x18, 0x49, 0x6E, 0x74, 0x65, 0x72, 0x6E, 0x65,
+    0x74, 0x20, 0x57, 0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20, 0x4C, 0x74,
+    0x64, 0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01, 0x06, 0x08,
+    0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0xDB, 0xC2, 0xB2, 0xB7,
+    0x83, 0x3C, 0xC8, 0x85, 0xE4, 0x3D, 0xE1, 0xF3, 0xBA, 0xE2, 0xF2, 0x90, 0x8E, 0x30, 0x25, 0x14,
+    0xE1, 0xF7, 0xA9, 0x82, 0x29, 0xDB, 0x9D, 0x76, 0x2F, 0x80, 0x11, 0x32, 0xEE, 0xAB, 0xE2, 0x68,
+    0xD1, 0x22, 0xE7, 0xBD, 0xB4, 0x71, 0x27, 0xC8, 0x79, 0xFB, 0xDC, 0x7C, 0x9E, 0x33, 0xA6, 0x67,
+    0xC2, 0x10, 0x47, 0x36, 0x32, 0xC5, 0xA1, 0xAA, 0x6B, 0x2B, 0xAA, 0xC9, 0xA0, 0x18, 0x30, 0x16,
+    0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x07, 0x31, 0x09, 0x0C, 0x07, 0x74,
+    0x65, 0x73, 0x74, 0x31, 0x32, 0x33
+};
+static uint16_t right_req_info_size = sizeof(right_req_info);
+
 uint8_t csr_pointer[LIBSPDM_MAX_CSR_SIZE] = {0};
 uint8_t *csr_data_pointer = csr_pointer;
 size_t global_csr_len;
@@ -42,7 +63,27 @@ libspdm_return_t libspdm_requester_get_csr_test_send_message(
         return LIBSPDM_STATUS_SUCCESS;
     case 0x3:
         return LIBSPDM_STATUS_SUCCESS;
-
+    case 0x4: {
+        const spdm_get_csr_request_t *spdm_request;
+        uint16_t requester_info_length;
+        uint16_t opaque_data_length;
+        uint8_t *opaque_data;
+        uint8_t *requester_info;
+
+        /* Obtain the real spdm_request */
+        spdm_request =
+            (const spdm_get_csr_request_t *)((const uint8_t *)request +
+                                             sizeof(libspdm_test_message_header_t));
+
+        requester_info_length = spdm_request->requester_info_length;
+        opaque_data_length = spdm_request->opaque_data_length;
+
+        requester_info = (void*)((size_t)(spdm_request + 1));
+        assert_memory_equal(requester_info, right_req_info, requester_info_length);
+        opaque_data = (void *)(requester_info + requester_info_length);
+        assert_memory_equal(opaque_data, m_csr_opaque_data, opaque_data_length);
+        return LIBSPDM_STATUS_SUCCESS;
+    }
     default:
         return LIBSPDM_STATUS_SEND_FAIL;
     }
@@ -116,6 +157,30 @@ libspdm_return_t libspdm_requester_get_csr_test_receive_message(
             libspdm_copy_mem(spdm_response + 1, global_csr_len, csr_data_pointer, global_csr_len);
         }
 
+        libspdm_transport_test_encode_message(spdm_context, NULL, false,
+                                              false, spdm_response_size,
+                                              spdm_response, response_size,
+                                              response);
+    }
+        return LIBSPDM_STATUS_SUCCESS;
+    case 0x4: {
+        spdm_csr_response_t *spdm_response;
+        size_t spdm_response_size;
+        size_t transport_header_size;
+
+        libspdm_read_requester_gen_csr((void *)&csr_data_pointer, &global_csr_len);
+        spdm_response_size = sizeof(spdm_csr_response_t) + global_csr_len;
+        transport_header_size = libspdm_transport_test_get_header_size(spdm_context);
+        spdm_response = (void *)((uint8_t *)*response + transport_header_size);
+
+        spdm_response->header.spdm_version = SPDM_MESSAGE_VERSION_12;
+        spdm_response->header.request_response_code = SPDM_CSR;
+        spdm_response->header.param1 = 0;
+        spdm_response->header.param2 = 0;
+        spdm_response->csr_length = (uint16_t)global_csr_len;
+        spdm_response->reserved = 0;
+        libspdm_copy_mem(spdm_response + 1, global_csr_len, csr_data_pointer, global_csr_len);
+
         libspdm_transport_test_encode_message(spdm_context, NULL, false,
                                               false, spdm_response_size,
                                               spdm_response, response_size,
@@ -240,6 +305,48 @@ void libspdm_test_requester_get_csr_case3(void **state)
 }
 
 
+/**
+ * Test 4: Send correct req_info and opaque_data
+ * Expected Behavior: get a RETURN_SUCCESS return code
+ **/
+void libspdm_test_requester_get_csr_case4(void **state)
+{
+    libspdm_return_t status;
+    libspdm_test_context_t *spdm_test_context;
+    libspdm_context_t *spdm_context;
+
+    uint8_t csr_form_get[LIBSPDM_MAX_CSR_SIZE] = {0};
+    size_t csr_len;
+
+    csr_len = LIBSPDM_MAX_CSR_SIZE;
+
+    spdm_test_context = *state;
+    spdm_context = spdm_test_context->spdm_context;
+    spdm_test_context->case_id = 0x4;
+    spdm_context->connection_info.version = SPDM_MESSAGE_VERSION_12 <<
+                                            SPDM_VERSION_NUMBER_SHIFT_BIT;
+
+    spdm_context->connection_info.connection_state =
+        LIBSPDM_CONNECTION_STATE_NEGOTIATED;
+    spdm_context->local_context.capability.flags = 0;
+    spdm_context->connection_info.capability.flags |=
+        SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CSR_CAP;
+
+    spdm_context->connection_info.algorithm.base_hash_algo =
+        m_libspdm_use_hash_algo;
+    spdm_context->connection_info.algorithm.base_asym_algo =
+        m_libspdm_use_asym_algo;
+
+    status = libspdm_get_csr(spdm_context, NULL,
+                             right_req_info, right_req_info_size,
+                             m_csr_opaque_data, m_csr_opaque_data_size,
+                             (void *)&csr_form_get, &csr_len);
+
+    assert_int_equal(status, LIBSPDM_STATUS_SUCCESS);
+    assert_int_equal(csr_len, global_csr_len);
+    assert_memory_equal(csr_form_get, csr_data_pointer, global_csr_len);
+}
+
 libspdm_test_context_t m_libspdm_requester_get_csr_test_context = {
     LIBSPDM_TEST_CONTEXT_VERSION,
     true,
@@ -256,6 +363,8 @@ int libspdm_requester_get_csr_test_main(void)
         cmocka_unit_test(libspdm_test_requester_get_csr_case2),
         /* Successful response to set certificate with a reset required */
         cmocka_unit_test(libspdm_test_requester_get_csr_case3),
+        /* Send req_info and opaque_data Successful response to get csr */
+        cmocka_unit_test(libspdm_test_requester_get_csr_case4),
     };
 
     libspdm_setup_test_context(
diff --git a/unit_test/test_spdm_responder/csr.c b/unit_test/test_spdm_responder/csr.c
index 02ebe298..ae8fd1ca 100644
--- a/unit_test/test_spdm_responder/csr.c
+++ b/unit_test/test_spdm_responder/csr.c
@@ -583,6 +583,150 @@ void libspdm_test_responder_csr_case6(void **state)
     free(m_libspdm_get_csr_request);
 }
 
+/**
+ * Test 7: receives a valid GET_CSR request message from Requester with non-null right req_info and opaque_data
+ * Expected Behavior: produces a valid CSR response message
+ **/
+void libspdm_test_responder_csr_case7(void **state)
+{
+    libspdm_return_t status;
+    libspdm_test_context_t *spdm_test_context;
+    libspdm_context_t *spdm_context;
+    size_t response_size;
+    uint8_t response[LIBSPDM_MAX_SPDM_MSG_SIZE];
+    spdm_csr_response_t *spdm_response;
+    spdm_get_csr_request_t *libspdm_get_csr_request;
+    uint8_t wrong_csr[LIBSPDM_MAX_CSR_SIZE];
+    libspdm_zero_mem(wrong_csr, LIBSPDM_MAX_CSR_SIZE);
+    char *csr;
+
+    spdm_test_context = *state;
+    spdm_context = spdm_test_context->spdm_context;
+    spdm_test_context->case_id = 0x7;
+    spdm_context->connection_info.version = SPDM_MESSAGE_VERSION_12 <<
+                                            SPDM_VERSION_NUMBER_SHIFT_BIT;
+
+    spdm_context->connection_info.connection_state =
+        LIBSPDM_CONNECTION_STATE_NEGOTIATED;
+    spdm_context->local_context.capability.flags = 0;
+    spdm_context->local_context.capability.flags |=
+        SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CSR_CAP;
+    spdm_context->connection_info.algorithm.base_hash_algo =
+        m_libspdm_use_hash_algo;
+    spdm_context->connection_info.algorithm.base_asym_algo =
+        m_libspdm_use_asym_algo;
+
+    libspdm_get_csr_request = malloc(sizeof(spdm_get_csr_request_t) +
+                                     sizeof(m_csr_opaque_data) +
+                                     sizeof(right_req_info));
+
+    libspdm_get_csr_request->header.spdm_version = SPDM_MESSAGE_VERSION_12;
+    libspdm_get_csr_request->header.request_response_code = SPDM_GET_CSR;
+    libspdm_get_csr_request->header.param1 = 0;
+    libspdm_get_csr_request->header.param2 = 0;
+    libspdm_get_csr_request->opaque_data_length = sizeof(m_csr_opaque_data);
+    libspdm_get_csr_request->requester_info_length = sizeof(right_req_info);
+
+    libspdm_copy_mem(libspdm_get_csr_request + 1, sizeof(right_req_info),
+                     right_req_info, sizeof(right_req_info));
+
+    libspdm_copy_mem((uint8_t *)(libspdm_get_csr_request + 1) + sizeof(m_csr_opaque_data),
+                     sizeof(m_csr_opaque_data),
+                     m_csr_opaque_data, sizeof(m_csr_opaque_data));
+
+    size_t libspdm_get_csr_request_size = sizeof(spdm_get_csr_request_t) +
+                                          sizeof(m_csr_opaque_data) +
+                                          sizeof(right_req_info);
+
+    response_size = sizeof(response);
+    status = libspdm_get_response_csr(spdm_context,
+                                      libspdm_get_csr_request_size,
+                                      libspdm_get_csr_request,
+                                      &response_size, response);
+    assert_int_equal(status, LIBSPDM_STATUS_SUCCESS);
+
+    spdm_response = (void *)response;
+    assert_int_equal(response_size, sizeof(spdm_csr_response_t) + spdm_response->csr_length);
+    assert_int_equal(spdm_response->header.request_response_code,
+                     SPDM_CSR);
+
+    /*check returned CSR not zero */
+    assert_memory_not_equal(spdm_response + 1, wrong_csr, spdm_response->csr_length);
+
+    csr = (char *)(spdm_response + 1);
+    assert_true(libspdm_find_buffer(csr, spdm_response->csr_length,
+                                    right_req_info_string, sizeof(right_req_info_string)));
+
+    free(libspdm_get_csr_request);
+}
+
+/**
+ * Test 8: receives a invalid GET_CSR request message from Requester With chaotic req_info and opaque_data
+ * Expected Behavior: generate an ERROR_RESPONSE with code SPDM_ERROR_CODE_INVALID_REQUEST
+ **/
+void libspdm_test_responder_csr_case8(void **state)
+{
+    libspdm_return_t status;
+    libspdm_test_context_t *spdm_test_context;
+    libspdm_context_t *spdm_context;
+    size_t response_size;
+    uint8_t response[LIBSPDM_MAX_SPDM_MSG_SIZE];
+    spdm_csr_response_t *spdm_response;
+    spdm_get_csr_request_t *libspdm_get_csr_request;
+    uint8_t wrong_csr[LIBSPDM_MAX_CSR_SIZE];
+    libspdm_zero_mem(wrong_csr, LIBSPDM_MAX_CSR_SIZE);
+
+    spdm_test_context = *state;
+    spdm_context = spdm_test_context->spdm_context;
+    spdm_test_context->case_id = 0x8;
+    spdm_context->connection_info.version = SPDM_MESSAGE_VERSION_12 <<
+                                            SPDM_VERSION_NUMBER_SHIFT_BIT;
+
+    spdm_context->connection_info.connection_state =
+        LIBSPDM_CONNECTION_STATE_NEGOTIATED;
+    spdm_context->local_context.capability.flags = 0;
+    spdm_context->local_context.capability.flags |=
+        SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CSR_CAP;
+    spdm_context->connection_info.algorithm.base_hash_algo =
+        m_libspdm_use_hash_algo;
+    spdm_context->connection_info.algorithm.base_asym_algo =
+        m_libspdm_use_asym_algo;
+
+    libspdm_get_csr_request = malloc(LIBSPDM_RECEIVER_BUFFER_SIZE);
+    libspdm_get_csr_request->header.spdm_version = SPDM_MESSAGE_VERSION_12;
+    libspdm_get_csr_request->header.request_response_code = SPDM_GET_CSR;
+    libspdm_get_csr_request->header.param1 = 0;
+    libspdm_get_csr_request->header.param2 = 0;
+
+    /* Swap right_req_info and m_csr_opaque_data */
+    libspdm_get_csr_request->opaque_data_length = sizeof(right_req_info);
+    libspdm_get_csr_request->requester_info_length = sizeof(m_csr_opaque_data);
+    libspdm_copy_mem(libspdm_get_csr_request + 1, sizeof(m_csr_opaque_data),
+                     m_csr_opaque_data, sizeof(m_csr_opaque_data));
+    libspdm_copy_mem((uint8_t *)(libspdm_get_csr_request + 1) + sizeof(right_req_info),
+                     sizeof(right_req_info),
+                     right_req_info, sizeof(right_req_info));
+
+    size_t libspdm_get_csr_request_size = sizeof(spdm_get_csr_request_t) +
+                                          sizeof(m_csr_opaque_data) +
+                                          sizeof(right_req_info);
+
+    response_size = sizeof(response);
+    status = libspdm_get_response_csr(spdm_context,
+                                      libspdm_get_csr_request_size,
+                                      libspdm_get_csr_request,
+                                      &response_size, response);
+    assert_int_equal(status, LIBSPDM_STATUS_SUCCESS);
+    assert_int_equal(response_size, sizeof(spdm_error_response_t));
+    spdm_response = (void *)response;
+    assert_int_equal(spdm_response->header.request_response_code,
+                     SPDM_ERROR);
+    assert_int_equal(spdm_response->header.param1,
+                     SPDM_ERROR_CODE_INVALID_REQUEST);
+    assert_int_equal(spdm_response->header.param2, 0);
+    free(libspdm_get_csr_request);
+}
+
 libspdm_test_context_t m_libspdm_responder_csr_test_context = {
     LIBSPDM_TEST_CONTEXT_VERSION,
     false,
@@ -603,6 +747,10 @@ int libspdm_responder_csr_test_main(void)
         cmocka_unit_test(libspdm_test_responder_csr_case5),
         /* Responder need reset to gen csr*/
         cmocka_unit_test(libspdm_test_responder_csr_case6),
+        /* Success Case for csr response with non-null right req_info and opaque_data */
+        cmocka_unit_test(libspdm_test_responder_csr_case7),
+        /* Failed Case for csr response  With chaotic req_info and opaque_data */
+        cmocka_unit_test(libspdm_test_responder_csr_case8),
     };
 
     libspdm_setup_test_context(&m_libspdm_responder_csr_test_context);
-- 
2.39.1.windows.1

